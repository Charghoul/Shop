model Shop {

server Server {
	Service service;
}

abstract server Service {
}
abstract server ServiceShop extends Service{
	observe ProduktKatalog produktKatalog;
}
server ServiceKunde extends ServiceShop {
	SuchManager suchManager;
	observe no-view Warenlager warenlager;
	public one-to-one (no-view myServiceKunde) Konto konto;
	one-to-one (no-view myServiceKunde) EinkaufsManager einkaufsManager;
	no-view LieferartManager lieferartManager;
	observe BestellManager  bestellManager;
	void neuePosition(EinkaufsManager einkaufsManager, Artikel artikel {produktKatalog}, Integer menge) throws UserException;
	void vorbestellen(EinkaufsManager einkaufsManager checked, Lieferart lieferart {lieferartManager});
	void bestellen(EinkaufsManager einkaufsManager checked, Lieferart lieferart {lieferartManager});
	void aendereMenge(Position position, Integer menge) throws ExcLagerbestandUnderZero, ExcLagerbestandOverMax;
	void zuEinkaufswagenHinzufuegen(Artikel artikel, Integer menge);
	void zuruecksenden(PositionInBestellung position checked);
	void allesZuruecksenden(Bestellung bestellung checked);
	void annehmen(Bestellung bestellung checked);
	void entfernePosition(Position position);
	void einzahlen(Konto konto, Integer betrag);
	void auszahlen(Konto konto, Integer betrag) throws ExcAuszahlungGroesserGutgaben;
	void suchen(String bezeichnung);
}
server ServiceAdmin extends ServiceShop {
	observe KundenManager kundenManager;
	Warenlager warenlager;
	ArtikelManager artikelManager;
	LieferartManager lieferartManager;
	one-to-one HerstellerManager herstellerManager;
	observe ZeitManager zeitManager;
	no-view void aendereHstLieferzeit(Artikel artikel, Integer hstLieferzeit);
	no-view 	void aendereMinLagerbestand(Artikel artikel, Integer minLagerbestand);
	no-view 	void aendereMaxLagerbestand(Artikel artikel, Integer maxLagerbestand);
	no-view 	void aenderePreis(Artikel artikel, Integer preis);
	no-view 	void aendereBezeichnung(Artikel artikel, String bezeichnung);
	void neuerArtikel(ArtikelManager artikelManager, String artikelnummer, String bezeichnung, Integer preis, Integer minLagerbestand, 		Integer maxLagerbestand, Integer hstLieferzeit);
	void produktgruppeHinzufuegen(Produktgruppe produktgruppe, String name)  throws ExcAlreadyExists, CycleException;
	void produktgruppeEntfernen(Produktgruppe produktgruppe);
	void artikelAnhaengen( Produktgruppe produktgruppe, Artikel artikel {artikelManager})  throws ExcAlreadyExists, CycleException;
	void artikelAbhaengen(Produktgruppe produktgruppe, Artikel artikel);
	void statusVerkauf@@freigeben(Artikel artikel checked);
	void statusAuslauf@@einstellen(Artikel artikel checked);
	void neueLieferArt(LieferartManager lieferartManager, String name, Integer lieferzeit, Integer preis) throws ExcAlreadyExists;
	void artikelEinlagern(Warenlager warenlager, Artikel artikel {artikelManager}, Integer menge);
	void artikelEntnehmen(Warenlager warenlager, Artikel artikel {artikelManager}, Integer menge);
	void artikelEntfernen(Warenlager warenlager, Position position {warenlager});
	void verringereMenge(Position position, Integer menge) throws ExcLagerbestandUnderZero;
	void aendereMenge(Position position, Integer menge) throws ExcLagerbestandUnderZero, ExcLagerbestandOverMax;
	void erhoeheMenge(Position position, Integer menge) throws ExcLagerbestandOverMax;
	void neuerHersteller(HerstellerManager herstellerManager, String name) throws ExcAlreadyExists;
	void aendereHersteller(Hersteller hersteller, String name) throws ExcAlreadyExists;
	void herstellerHinzufuegen(Artikel artikel, Hersteller hersteller {herstellerManager}) throws ExcAlreadyExists;
	no-view void aendereAnnahmezeit(ZeitManager zeitManager,Integer neueZeit);
	no-view void aendereMaxAnlieferungsVersuche(ZeitManager zeitManager, Integer maxAnlieferungsVersuche);
	no-view void aendereRetoureZeit(ZeitManager zeitManager, Integer retoureZeit);
	no-view void aendereRueckversandGebuehr(LieferartManager lieferartManager,Integer percent);
	no-view void aendereStandardGuthaben(KundenManager kundenManager, Integer guthaben);
	no-view void aendereStandardLimit(KundenManager kundenManager, Integer limit);
	no-view void aendereLieferartPreis(Lieferart lieferart, Integer preis);
	no-view void aendereLieferartName(Lieferart lieferart, String name) ;
	no-view void aendereLieferartDauer(Lieferart lieferart, Integer dauer);
	
	
}
//Der Registrierservice ist notwendig, damit sich neue Kunden registrieren können. Man erreicht ihn indem man "Public" als Name einträgt und kein Passwort. In dem sich dann öffnenden Service kann der Kunde sich ein Benutzernamen und Passwort aussuchen und sich dann damit anmelden.
server ServiceRegister extends Service {
	//meldet den Kunden mit Benutzername und Passwort am Shop an
	active void register(String username, String passwort) throws ExcUserAlreadyExists;
}

//Der SuchManager zeigt die Suchergebnisse des Kunden an
class SuchManager{
	Artikel ** suchListe;
	//leert die suchListe
	void leeren();
	//zeigt den Artikel mit dem Namen bezeichnung in der Liste suchListe an. 
	active void anzeigen(String bezeichnung) throws ExcArtikelDoesNotExist;
}

//Der Artikelmanager verwaltet alle Artikel des Shops
singleton ArtikelManager{
	Artikel ** artikelListe;
	//Der Admin kann einen neuen Artikel mit einzigartiger Artikelnummer, Bezeichnung, Preis, minimalem und maximalem Lagerbestand und der Herstellerlieferzeit anlegen. 
	active void neuerArtikel(String artikelnummer, String bezeichnung, Integer preis, Integer minLagerbestand, 		Integer maxLagerbestand, Integer hstLieferzeit) throws UserException;
}

//Jedem ServiceKunde ist ein BestellManager zugeordnet, mit dem der Kunde seine Vorbestellungen und Lieferungen verwalten kann
class BestellManager{
	public Bestellung ** bestellListe;
	public Vorbestellung ** vorbestellListe;
	//von 0 hochlaufende BestellID, die dem Kunden angezeigt wird zu Unterscheidung der Bestellungen
	server-only Integer bestellID;
	server-only prior	public Konto konto;
	//Eine neue Bestellung wird mit den dazugehörigen Positionen, dem aktuellen warenwert und der vom Kunden gewählten Lieferart erstellt. Dazu kommt eine hochlaufende bestellID. Falls ein Artikel nicht vorhanden ist wird dies als Exception geworfen. Auch wird eine neue KndLieferung im ZeitManager erstellt
	Bestellung neueBestellung(Position ** positionsListe, Integer warenwert, Lieferart lieferart) throws ExcArtikelNichtVerfuegbar;
	//Eine neue Vorbestellung wird mit den dazugehörigen Positionen, dem aktuellen warenwert und der vom Kunden gewählten Lieferart erstellt.
	Vorbestellung neueVorbestellung(Position ** positionsListe, Integer warenwert, Lieferart lieferart);
	//Interne Funktion um den BestellManager zu aktualisieren
	event void benachrichtige();
	//prüft, ob eine der Vorbestellungen bereit zum versenden ist, wenn ja wird eine Bestellung mit den gleichen eigenschaften erstellt und die Vorbestellung gelöscht
	void pruefeVorbestellungen();	
}

//Der Produktkatalog wird beim Kunden angezeigt und vom Administrator gepflegt. Er dient nur zur Einordnung der Artikel in verschiedene Produktgruppen, um dem Kunden eine bessere Übersicht zu biete.
singleton ProduktKatalog{
	//#produktgruppen fungiert als root aller produktgruppen und wird beim erstellen des Produktkataloges angelegt.
	public Produktgruppe produktgruppen;
	//ruft die Funktion produktgruppeHinzufuegen() in der #produktgruppe auf und übergibt #name 
	event void produktgruppeHinzufuegen(Produktgruppe produktgruppe, String name)  throws ExcAlreadyExists, CycleException;
	//ruft prodGEntfernen() in der #produktgruppe auf
	event active void produktgruppeEntfernen##prodEntf(Produktgruppe produktgruppe) throws ExcHasNoParent;	
	//ruft artikelAnhaengen() in der #produktgruppe auf und übergibt #artikel
	event void artikelAnhaengen( Produktgruppe produktgruppe, Artikel artikel )  throws ExcAlreadyExists, CycleException;	
	//ruft artikelAbhaengen() in der #produktgruppe auf und übergibt den #artikel
	event void artikelAbhaengen(Produktgruppe produktgruppe, Artikel artikel);
	//eine Methode die genutzt wird um Updates der Artikel und Produktgruppen vom Admin dem Kunden anzuzeigen
	event void internalUpdate();
}

//Das Warenlager enthält alle Artikel mit den dazugehörigen aktuellen Beständen. 		
singleton Warenlager{
	public Position ** warenListe;
	//Entnimmt den Artikel #artikel #menge mal aus dem Warenlager. Bei einer Entnahme die den Lagerbestand unter Null senken würden wird eine Exception geworfen, ebenso wenn ein Artikel keinen Hersteller hat, da dann nicht nachbestellt werden kann, wenn der Lagerbestand unter den minimalen Lagerbestand fällt. Liegt der Lagerbestand des Artikels nach der Entnahme unter dem minimalen Lagerbestand des Artikels wird die Funktion "nachbestellen" im Warenlager auf.
	active void artikelEntnehmen##artEntf(Artikel artikel, Integer menge) throws ExcLagerbestandUnderZero, ExcArtikelHatKeinenHersteller;
	//Lagert den Artikel #artikel #menge mal ein. Wenn die Einlagerung den maximalen Lagerbestand überschreiten würde wird eine Exception geworfen. Wenn der Artikel noch nicht im Warenlager vorhanden ist wird eine neue Position erstellt mit #artikel und #menge.
	event active void artikelEinlagern(Artikel artikel, Integer menge) throws ExcLagerbestandOverMax;
	//löscht eine Position aus dem Warenlager
	active void artikelEntfernen##artEntn(Position position);
	//eine Funktion um einfach zu prüfen, ob eine Position der #positionsListe nicht ausreichend verfügbar ist. Ist dies der Fall wird die erste nicht ausreichend verfügbare Position zurückgegeben, sonst wird null zurück gegeben.
	Position nichtVerfPruefen(Position ** positionsListe);
	//erzeugt eine HstLieferung im Zeitmanager mit dem Artikel #artikel und der Menge #menge.
	void nachbestellen(Artikel artikel, Integer menge) throws ExcArtikelHatKeinenHersteller;
}

//Der ZeitManager verwaltet alles was mit der zeitlichen Abfolge von Ereignissen zu tun hat
singleton ZeitManager {
	//eine Liste aller erstellten ZeitObjekte außer AnnahmeZeiten, diese werden in einer seperaten Liste gepflegt
	observe ZeitObjekt ** zeitObjektListe;
	//eine Liste aller AnnahmeZeitenObjekte, welche seperat angelegt werden, da sonst beim Durchlauf der ZeitObjekte ein Problem entsteht
	server-only ZeitObjekt ** annahmeZeiten;
	public Integer annahmezeit@@AnnahmezeitInZeitEinheiten;
	public Integer maxAnlieferungsVersuche##maxAnl;
	public Integer retoureZeit@@standardRetourenZeitInZE;
	//Methode die aufgerufen wird, wenn eine ZeitEinheit abgelaufen ist und dann in jedem ZeitObjekt die Methode reduceTime aufruft
	void handleTimeUnitElapsed() ;
	//erstellt eine neue HerstellerLieferung mit dem Artikel #artikel und der Menge #menge und fügt sie der Liste #zeitObjektListe hinzu
	event void neueHstLieferung(Artikel artikel, Integer menge);
	//erstellt eine neue KundenLieferung die die Bestellung #bestellung enthält und fügt sie der Liste #zeitObjektListe hinzu
	event void neueKndLieferung(Bestellung bestellung);
	//erstellt eine neue KundenAnnnahme mit der KundenLieferung #kndLieferung und fügt sie der Liste #annahmeZeiten hinzu
	event void neueKndAnnahme(KndLieferung kndLieferung);
	//erstellt eine neue PositionsRetoure mit der PositionInBestellung #position und fügt sie der Liste #zeitObjektListe hinzu
	event void neueRetourePosition(PositionInBestellung position);
	//erstellt eine neue LieferungsRetoure mit der KundenLieferung #kndLieferung und fügt sie der Liste #zeitObjektListe hinzu
	event void neueRetoureLieferung(KndLieferung kndLieferung);
	//Methode die genutzt wird um Updates innerhalb der ZeitObjekte an die Oberfläche weiterzuleiten
	event void forwardInternalEvent();
	//entfernt ein ZeitObjekt aus der Liste 
	void removeZeitObjekt(ZeitObjekt zeitObjekt);
	//ermöglicht es dem Admin die AnnahmeZeit zu ändern
	void aendereAnnahmezeit(Integer neueZeit);
	//ermöglicht es dem Admin die maximalen Anlieferungsversuche zu ändern
	void aendereMaxAnlieferungsVersuche(Integer maxAnlieferungsVersuche);
	//ermöglicht es dem Admin die RetourenZeit zu ändern
	void aendereRetoureZeit(Integer retoureZeit);
}

//ZeitObjekte sind alle Objekte die für die zeitliche Abfolge von Ereignissen nötig sind
abstract class ZeitObjekt{
	//#remainingTime enthält die noch verbliebene Zeit des ZeitObjekts in ZeitEinheiten. Die Länge einer ZeitEinheit lässt sich im Code beliebig anpassen.
	public prior Integer remainingTime;
	//Status des ZeitObjekts, der in reduceTime() 
	//dafür genutzt wird zu überprüfen, ob auf ein ZeitObjekt handleTimeElapsed() ausgeführt werden soll
	server-only public prior Status status;
	//ruft, wenn die remainingTime mit dem Aufruf auf 0 sink,t die Methode handleTimeElapsed() im zeitObjekt auf
	event void reduceTime();
	//ruft die Methode zeitAbgelaufen() in den einzelnen ZeitObjekten auf
	void handleTimeElapsed();
	//implementiert die jeweiligen Aufgaben der einzelnen ZeitObjekte, siehe KndLieferung, HstLieferung, etc
	event void zeitAbgelaufen();
}

//lässt den Admin die Hersteller verwalten
class HerstellerManager{
	//Liste aller Hersteller
	Hersteller ** herstellerListe;
	//legt einen neuen Hersteller mit dem Namen #name an und fügt ihn der Liste #herstellerListe hinzu
	void neuerHersteller(String name) throws ExcAlreadyExists;
}

//Jedem ServiceKunde ist ein EinkaufsManager zugeordnet, der als Einkaufswagen fungiert. 
class EinkaufsManager{
	//Die Liste enthält alle Positionen die der Kunde kaufen möchte
	public Position ** einkaufsListe;
	//dem EinkaufsManager ist der BestellManager zugeordnet, damit die Bestellung in den richigen Bestellmanager gelegt werden kann, wenn der Kunde die einkaufsListe bestellt oder vorbestellt
	prior no-view BestellManager bestellManager;
	//Die Methode bestellen() erstellt eine KndLieferung im ZeitManager aus der #einkaufsListe mit der Lieferart #lieferart und eine Bestellung im BestellManager mit den gleichen Parametern. Es wird eine Exception geworfen, falls der zu bestellende Warenwert inklusive Lieferkosten über dem Kontoguthaben des Kunden liegt oder wenn ein Artikel aus der #einkaufsListe nicht verfügbar ist
	active void bestellen(Lieferart lieferart) throws ExcArtikelNichtVerfuegbar, ExcWarenwertUeberKontoguthaben;
	//Die Methode vorbestellen() erzeugt eine Vorbestellung im BestellManager. Es wird eine Exception geworfen, falls der Warenwert der inklusive Lieferkosten über dem Kontoguthaben des Kunden liegt
	active void vorbestellen(Lieferart lieferart) throws ExcWarenwertUeberKontoguthaben;
	//fügt der #einkaufsListe eine neue Position hinzu, bestehend aus #artikel und #menge. Es wird eine Exception geworfen, falls schon eine Position mit dem Artikel #artikel in der #einkaufsListe vorhanden ist, wenn der #artikel im Status Neuanlage ist, oder wenn #menge über dem maximalen Lagerbestand des Artikels liegt.
	void neuePosition(Artikel artikel, Integer menge) throws ExcArtikelAlreadyExists, ExcLagerbestandOverMax, ExcArtikelNochNichtVerfuegbar;
	//löscht die Position #position aus der #einkaufsListe
	void entfernePosition(Position position);
	//gibt den gesamten Warenwert der #einkaufsListe wieder
	Integer gibGesamtPreis();
}

//Der LieferartManager ermöglicht es dem Admin die verschiedenen Lieferarten zu verwalten
singleton LieferartManager{
	//Liste aller Lieferarten
	public Lieferart ** lieferartenListe;
	//im LieferartManager wird auch die Standard Rückversandgebühr in Prozent gepflegt
	public prior Integer rueckversandGebuehr##rckG@@RueckversandgebuehrenInProzent;
	//legt eine neue Lieferart mit dem Namen #name, der Lieferzeit #lieferzeit in Zeiteinheiten und dem Preis #preis in Cent an und fügt sie der #lieferartenListe hinzu. Es wird eine Exception geworfen, falls eine Lieferart mit dem Namen bereits existiert
	void neueLieferart(String name, Integer lieferzeit, Integer preis) throws ExcAlreadyExists;
	//ermöglicht dem Admin das ändern der Standard Rückversandgebühr
	void aendereRueckversandGebuehr(Integer percent);
}

//der KundenManager zeigt dem Admin eine Liste aller Kunden, die sich registriert haben.
singleton KundenManager{
	//Liste aller Kunden die sich registriert haben
	public Kunde**kundenListe;
	//das untere Standard Limit eines Kunden, was beim Erstellen des Kunden übernommen wird
	public Integer standardLimit;
	//das Standard Guthaben eines Kunden, was beim Erstellen des Kunden übernommen wird
	public Integer standardGuthaben;
	//ändert das Standardguthaben zu #guthaben
	void aendereStandardGuthaben(Integer guthaben);
	//ändert das StandardLimit zu #limit
	void aendereStandardLimit(Integer limit);
}

//Diese Klasse wird genutzt um Benutzernamen und Passwort von Kunden zu speichern und nachher zu prüfen, ob schon ein Kunde mit diesem Namen existiert. Er wird angelegt wenn sich der Kunde im ServiceRegister registriert
class Kunde{
	//Name des Kunden
	indexed prior String benutzername;
	//Passwort des Kunden
	prior String passwort;
}

//Jedem ServiceKunde ist ein Konto zugeordnet, um sein Guthaben zu verwalten
class Konto{
	//Der aktuelle Kontostand des Kontos wird in #kontostand gespeichert
	public prior Integer kontostand;
	//Das untere Limit des Kontos, also bis wohin der Kunde das Guthaben verringern darf, wird in #limit gespeichert
	public-write prior Integer limit;
	//Speichert den aktuell reservierten Warenwert des Kunden. Das heißt der Wert alle Bestellungen und Vorbestellungen inklusive Lieferkosten die noch nicht bezahlt wurden wird hier gespeichert, um einfacher prüfen zu können, ob der Kunde eine neue Bestellung aufgeben darf oder sich damit unter das Limit fallen würde
	public prior Integer reserviert;
	//bucht den Betrag #betrag vom #kontostand ab
	void abbuchen(Integer betrag);
	//erhöhrt den #kontostand um den Betrag #betrag
	void einzahlen(Integer betrag);
	//erlaubt dem Kunden sich Geld vom Konto wieder auszahlen zu lassen. #betrag wird dann vom #kontostand abgebucht. Wirft eine Exception wenn #betrag > #kontostand ist.
	void auszahlen(Integer betrag) throws ExcAuszahlungGroesserGutgaben;
	//erhöht #reserviert um den Betrag #betrag
	void reserviere(Integer betrag);
	//verringert #reserviert um den Betrag #betrag
	void verringereReserviert(Integer betrag);
	//ändert #limit des Kontos auf #limit
	void aendereLimit(Integer limit);
}
//Hierarchie die für die Produktgruppen nötig ist
hierarchy Hierarchie;

//Abstrakte Klasse die alle Komponenten beinhaltet, also Artikel und Produktgruppen
abstract class Komponente {
}

//Artikel können vom Kunden bestellt werden und erben von der abstrakten Klasse Komponente. Sie werden im ArtikelManager gepflegt und für den Kunden im ProduktKatalog angezeigt
class Artikel extends Komponente{
	//Artikelnummer zum eindeutigen identifizieren des Artikels, diese ist unique
	prior indexed String artikelnummer;
	//Bezeichung des Artikels ist zusammen mit dem Hersteller unique
	prior indexed String bezeichnung;
	//Preis des Artikels in Cent
	public prior Integer preis;
	//minimaler Lagerbestand des Artikels
	public prior Integer minLagerbestand;
	//maximaler Lagerbestand des Artikels
	public prior Integer maxLagerbestand;
	//Lieferzeit des Herstellers für diesen Artikel
	public prior Integer hstLieferzeit;
	//Verkaufsstatus des Artikels, wichtig dafür ob nachbestellt wird und ob der Kunde den Artikel in den Einkaufswagen legen kann kann
	public prior skip-view Artikelstatus artikelstatus;
	//Hersteller des Artikels, zusammen mit der Bezeichnung ist der Artikel unique
	public no-view Hersteller hersteller;
	//ändert die HerstellerLieferzeit des Artikels auf #hstLieferzeit
	void aendereHstLieferzeit(Integer hstLieferzeit);
	//ändert den minimalen Lagerbestand des Artikels auf #minLagerbestand. Wirft eine Exception, wenn #minLagerbestand größer ist als  der aktuelle #maxLagerbestand
	active void aendereMinLagerbestand##aendMin(Integer minLagerbestand) throws ExcIllogicalDataEntry;
	//ändert den maximalen Lagerbestand des Artikels auf #maxLagerbestand. Wirft eine Exception, wenn der #maxLagerbestand kleiner ist als der aktuelle #minLagerbestand des Artikels
	active void aendereMaxLagerbestand##aendMax(Integer maxLagerbestand) throws ExcIllogicalDataEntry;
	//ändert den Preis des Artikels auf #preis
	void aenderePreis(Integer preis);
	//ändert die Bezeichnung des Artikels auf #bezeichnung, wirft eine Exception wenn schon ein Artikel mit der Bezeichnung #bezeichnung und dem gleichen Hersteller exisitert
	active void aendereBezeichnung(String bezeichnung) throws ExcAlreadyExists;
	//ändert den #artikelstatus auf Verkauf. Wirft eine Exception wenn dem Artikel kein Hersteller zugeordnet wurde oder der Status vorher schon Verkauf war
	active void statusVerkauf() throws ExcInconsistentStatusChange, ExcArtikelHatKeinenHersteller;
	//ändern den #artikelstatus auf Auslauf. Wirft eine Exception wenn der Status schon Auslauf war, oder der Status Verkauf übersprungen wird
	active void statusAuslauf() throws ExcInconsistentStatusChange;
	//fügt einen Artikel zum Einkaufswagen #einkaufsManager des Kunden hinzu, indem die Funktion neuePosition() des #einkaufsManager aufgerufen wird, Wirft alle Exceptions der Funktion neuePosition()
	active void zuEinkaufswHinz(Integer menge, EinkaufsManager einkaufsManager) throws UserException;
	//fügt dem Artikel den Hersteller #hersteller hinzu. Wirft eine Exception wenn schon ein Artikel mit #bezeichnung und dem neuen #hersteller existiert
	void herstellerHinzufuegen(Hersteller hersteller) throws ExcAlreadyExists;
}

//Wird benutzt um die Artikel einzuordnen im Produktkatalog. Jede Produktgruppe kann weitere Produktgruppen oder Artikel enthalten
class Produktgruppe extends Komponente{
	//#komponentenliste enthält die Komponenten (also Artikel und Produktgruppen) dieser Produktgruppe
	symmetric Komponente**komponentenListe hierarchy Hierarchie;
	//Name der Produktgruppe, der unique ist
	prior indexed String name;
	//erstellt eine neue Produktgruppe mit nem Namen #name und fügt sie der #komponentenListe hinzu. Wirft eine Exception, wenn der schon eine Produktgruppe mit dem Namen #name besteht
	void produktgruppeHinzufuegen(String name) throws ExcAlreadyExists, CycleException;
	//ruft removeChild() in der Parent Produktgruppe dieser Produktgruppe auf. Wirft eine Exception wenn die Produktgruppe keinen Parent besitzt
	void prodGEntfernen() throws ExcHasNoParent;
	//entfernt die Produktgruppe #child aus der #komponentenListe
	void removeChild(Produktgruppe child);
	//fügt den Artikel #artikel zu der #komponentenListe dieser Produktgruppe hinzu. Wirft eine Exception wenn der Artikel schon in der #komponentenListe vorhanden ist
	void artikelAnhaengen(Artikel artikel) throws ExcAlreadyExists, CycleException;
	//entfernt den Artikel #artikel aus der #komponentenListe
	void artikelAbhaengen(Artikel artikel);
}

//Hersteller werden Artikeln zugeordnet, fungieren nur als Dummy
class Hersteller{
	//Der Name des Herstellers ist unique
	prior indexed String name;
	//ändert den Namen des Herstellers zu #name. Wirft eine Exception wenn schon ein Hersteller mit diesem Namen existiert
	void aendereHersteller(String name) throws ExcAlreadyExists;
}

//Abstrakte Klasse, die Vorbestellungen und  Bestellungen beinhaltet
abstract class BestellungAbstrakt##BstAbstr{
	//Bestellmanager der der Bestellung oder Vorbestellung zugeordnet ist, um zum Beispiel das Entfernen einer Bestellung aus dem BestellManager des Kunden zu ermöglichen und eine eindeutige der Bestellung zum Kunden zu gewährleisten
	public prior server-only BestellManager bestellManager;
	//Warenwert der Bestellung oder Vorbestellung wird zwischengespeichert, damit sie nicht immer neu abgefragt werden muss
	public prior Integer warenwert;
	//Lieferart der Bestellung oder Vorbestellung, die der Kunde ausgewählt hat
	public prior Lieferart lieferart;
	//fügt einer Bestellung oder Vorbestellung die#positionsListe hinzu, wird genutzt wenn eine Bestellung oder Vorbestellung neu erstellt wird
	void listeHinzufuegen(Position ** positionsListe);
}

//Bestellungen werden im Bestellmanager des Kunden angezeigt, zeigen aktuelle Lieferinformationen an und der Kunde kann mit ihnen agieren wenn sie geliefert wurden
class Bestellung extends BestellungAbstrakt{
	//enthält die Positionen der Bestellung
	public PositionInBestellung ** positionsListe;
	//enthält die KndLieferung des ZeitManagers um die Lieferinformationen anzuzeigen
	server-only public KndLieferung kndLieferung;
	//bestellID damit der Kunde die Bestellungen auseinander halten kann
	prior indexed Integer bestellID;
	//Bestellstatus, damit der Kunde weiß ob er die Bestellung annehmen kann und ob sie gerade hin oder zurück geschickt wird
	public no-view Bestellstatus bestellstatus;
	//ändert den Status den bestellstatus der Bestellung auf #bestellstatus
	void aendereStatus(Bestellstatus bestellstatus);
	//nimmt die Bestellung an, ist nur möglich wenn sich die Bestellung im #bestellstatus geliefert befindet. Ändert den #bestellstatus auf angenommen, verringert #reserviert und #kontostand des ServiceKunde um den #warenwert der KndLieferung. Ebenfalls wird der Status der KndLieferung auf deactivated gesetzt
	void annehmen();
	//sendet die ganze Bestellung zurück. Dabei wird die Bestellung aus dem BestellManager entfernt, #reserviert um den Warenwert der KndLieferung verringert und die Rücksendegebühr vom Konto abgezogen
	active void allesZuruecksenden##allZrck();
	//berechnet den aktuellen Warenwert der Bestellung
	Integer berechneWarenwert();
	//fügt 
	void lieferungHinzufuegen(KndLieferung lieferung);
	
}
class Vorbestellung extends BestellungAbstrakt{
	public Position ** positionsListe;
	void stornieren();
}

class KndLieferung extends ZeitObjekt{
	prior public Bestellung bestellung;
	public Integer lieferversuche;
	event void erneutSenden();
}

class HstLieferung extends ZeitObjekt{
	prior Artikel artikel;
	prior Integer menge;
}

class KndAnnahme extends ZeitObjekt{
	prior KndLieferung kndLieferung;
}

class RetoureLieferung extends ZeitObjekt{
	prior KndLieferung kndLieferung;
}

class RetourePosition extends ZeitObjekt{
	prior PositionInBestellung position;
}

abstract class PositionAbstrakt {
	public no-view prior Artikel artikel;
	public prior Integer menge;
}
class Position extends PositionAbstrakt{
	void verringereMenge(Integer menge) throws ExcLagerbestandUnderZero;
	void aendereMenge(Integer menge) throws ExcLagerbestandUnderZero, ExcLagerbestandOverMax;
	void erhoeheMenge(Integer menge) throws ExcLagerbestandOverMax;
	void entfernePosition(EinkaufsManager einkaufsManager);
}

class PositionInBestellung##posInBest extends PositionAbstrakt{
	public prior server-only Bestellung bestellung;
	active void zuruecksenden();
}

class Lieferart{
	indexed prior String name;
	public prior Integer lieferzeit;
	public prior Integer preis;
	void aendereLieferartPreis(Integer preis);
	active void aendereLieferartName(String name) throws ExcAlreadyExists;
	void aendereLieferartDauer(Integer dauer);
}

//Ein Status für die Zeitobjekte, um sie nach Ablauf der Zeit zu deaktivieren
abstract class Status {}
singleton activated extends Status{}
singleton deactivated extends Status{}

//Der Artikelstatus bestimmt, ob ein Artikel verkauft oder nachbestellt wird 
abstract class Artikelstatus{}
singleton Neuanlage extends Artikelstatus{}
singleton Verkauf extends Artikelstatus{}
singleton Auslauf extends Artikelstatus{}

//Der Bestellstatus ist als Information für den Kunden gedacht
abstract class Bestellstatus{}
singleton Verarbeitung extends Bestellstatus{}
singleton Hinversand extends Bestellstatus{}
singleton Geliefert extends Bestellstatus{}
singleton Angenommen extends Bestellstatus{}
singleton Rueckversand extends Bestellstatus{}

exception ExcIllogicalDataEntry{}
exception ExcAuszahlungGroesserGutgaben{}
exception ExcWarenwertUeberKontoguthaben{}
exception ExcArtikelNochNichtVerfuegbar{}
exception ExcArtikelHatKeinenHersteller{}
exception ExcArtikelNichtVerfuegbar{}
exception ExcEinkaufslisteNichtVerfuegbar{}
exception ExcHasNoParent{}
exception ExcHasChildren{}
exception ExcInconsistentStatusChange{}
exception ExcAlreadyExists{}
exception ExcLagerbestandOverMax{}
exception ExcLagerbestandUnderZero{}
exception ExcLieferartAlreadyExists{}
exception ExcArtikelAlreadyExists{}
exception ExcUserAlreadyExists{}
exception ExcStatusDidNotChange{}
exception ExcArtikelDoesNotExist{}
}

